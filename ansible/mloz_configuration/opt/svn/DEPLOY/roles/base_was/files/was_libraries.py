"""
That file contain all function imported in the New Was deployment Role for Ansible.

.. note:: 
    **AdminConfig and AdminTask** are Java Object obtain when python script is launched by **wsadmin.sh**.
  
"""
import sys
sys.path.append('/data/wsadmin/share')
sys.path.append('/data/wsadmin/share/procs')
sys.path.append('/data/wsadmin/datasources')
sys.path.append('/data/wsadmin/datasources/config')


from com.ibm.ws.scripting import ScriptingException
#import save
import createserver, serverprocs, checkdatasource, servers, jaas, os
#import validateparams
from types import StringType, DictType

#validateparams.validateparams([])


def set_process_exec_opts(server_id, runAsUser, runAsGroup, runInProcessGroup='0', processPriority='20', umask='022', **kwargs):
    """ Set Process Execution of the JVM::

        Application servers > DDRA_566_MBR1 > Process execution

    :param str server_id: was server id
    :param str runAsUser: user defined in YML, (default)
    :param str runAsGroup: group defined in YML, (default)
    :param str runInProcessGroup: integer value converted in string (default: 0)
    :param str processPriority: integer value converted in string (default: 20)
    :param str umask: posix permission (default: 022)
    """
    wasid = AdminConfig.getid(server_id)
    process_exec = AdminConfig.list('ProcessExecution', wasid)
    opts = runAsUser, runAsGroup, runInProcessGroup, processPriority, umask
    opts = '[[runAsUser "%s"] [runAsGroup "%s"] [runInProcessGroup "%s"] [processPriority "%s"] [umask "%s"]]' % opts
    AdminConfig.modify(process_exec, opts)
    print('Process Execution options updated.')


def ymldict2java_opt_list(ymldict):
    """ Get yml dictionary options and return java list like options::

        [ [key1, val1], [key2, val2] ]
    
    :param dict ymldict: Dictionary generated by Yml files
    """
    opts = []
    for key, val in ymldict.items():
        if type(val) == DictType:
            tmp = ymldict2java_opt_list(val)
            opts.append(tmp)
        else:
            opts.append([key, val])

    return opts


def ymldict2java_list_string(ymldict):
    """ Get yml dictionary options and return java string (command args) like options::

        [ -%s %s -%s %s -%s %s ]
    
    :param dict ymldict: Dictionary generated by Yml files
    """
    opts = []
    for key, val in ymldict.items():
        if type(val) == DictType:
            tmp = ymldict2java_list_string(val)
            tmp = '-%s %s' % (key, tmp)
            opts.append(tmp)
        else:
            opts.append('-%s %s' % (key, val))

    return opts


def set_custom_prop_entry(env_entry, name, value, type='java.lang.String', **kwargs):
    """ Set entry custom property to Resource Entry::

        Resources > Resource Environment > Resource environment entries

    :param str env_entry: Entry created in Resource Provider
    :param str javatype: The java type object to define value: java.lang.String
    :param str key, val: Key, Value for the Property
    """
    AdminConfig.create('J2EEResourcePropertySet', env_entry, [['resourceProperties',[[['name', name],['value', value], ['type', type]]]]])


def get_or_create_env_entries(wasid, provider, referc, name, jndiName, **kwargs):
    """ Get or Create and return a Resource Entry::

        Resources > Resource Environment > Resource environment entries

    :param str wasid: String id (ex: /Cell:RefNetwork/ServerCluster:BL2_apps5/)
    :param str provider: Provider obj returned by get_or_create_env_provider()
    :param str referc: Java Object obained by get_or_create_env_provider()
    :param str name: Name for the new resource entry
    :param str jndiName: jndiName for the new resource entry
    :param str args: with * args get in one list all additional arguments not filtered by not positional args
    :return: Java Object Resource environment entry
    :rtype: srt
    """
    msg = 'Resource environment entry %s for %s %s' % (name, provider, '%s')
    envEntries = AdminConfig.list('ResourceEnvEntry', AdminConfig.getid(wasid))

    if envEntries.find(name) >= 0:
        msg = msg % 'already exists'
        print(msg)
        return [ el for el in envEntries.splitlines() if el.startswith(name) ][0]
    else:
        opts = '[[name "%s"] [jndiName "%s"] [referenceable "%s"]]' % (name, jndiName, referc)
        msg = msg % 'created'
        tmp = AdminConfig.create('ResourceEnvEntry', provider, opts)
        print(msg)
        return tmp


def get_or_create_env_provider(wasid, path, libname, libfile):
    """ Get or Create and return a Resource Provider::

        Resources > Resource Environment > Resource Environment Providers

    :param str id: WAS application ID (java formated, ex: '/Cell:PreProdNetwork/Node:PreProdNodetest/Server:M998CQU_test_MBR1/')
    :param str libname: Name of the library created by createLibrary
    :param str libfile: Filename of the config_jndi.jar
    :return: tuple with Java Object Resource environment Provider & Java Object Referenceable
    :rtype: tuple
    """
    def createLibrary(wasid, libname, libfile):
        """ Create library to contact config_jndi.jar

        :param str wasid: String id (ex: /Cell:RefNetwork/ServerCluster:BL2_apps5/)
        :param str libname: Name of the library created by createLibrary
        :param str libfile: Filename of the config_jndi.jar
        """
        msg = 'Shared Library for %s %s' % (wasid, '%s')
        if len(AdminConfig.list('Library', AdminConfig.getid(wasid))) > 0:
            msg = msg % ('already exists')
            print(msg)
        else:
            msg = msg % 'created'
            opts = '[[name "%s"] [classPath "%s"] [nativePath ""] [isolatedClassLoader "false"] [description "jar with classes to retrive information from JNDI"]]' % (libname, libfile)
            AdminConfig.create('Library', AdminConfig.getid(wasid), opts)
            print(msg)

    msg = 'Resource environment provider for %s %s' % (wasid, '%s')
    libfile = os.path.join(path, 'lib', libfile)
    all_env_providers = AdminConfig.list('ResourceEnvironmentProvider', AdminConfig.getid(wasid)).splitlines()

    if len(all_env_providers) > 0:
        provider = AdminConfig.list('ResourceEnvironmentProvider', AdminConfig.getid(wasid))
        referc = AdminConfig.list('Referenceable', provider)
        msg = msg % 'already exists'
        print(msg)
    else:
        provider = AdminConfig.create('ResourceEnvironmentProvider', AdminConfig.getid(wasid), '[[name "ResourcesProviderForJNDI"]]')
        opts = '[[classname "be.mteam.config.server.jndi.ConfigServer"] [factoryClassname "be.mteam.config.server.jndi.ConfigServerFactory"]]'
        referc = AdminConfig.create('Referenceable', provider, opts , 'referenceables')
        msg = msg % 'created'
        print(msg)

    if os.path.isfile(libfile):
        createLibrary(wasid, libname, libfile)
    else:
        msg = 'Unable to create Shared Library %s for %s, %s does not exists' % (libname, wasid, libfile)
        print(msg)

    return (provider, referc)


def get_or_create_scheduler(id, kwargs):
    """ Get or Create Schedulers::

        Resources > Schedulers

    :param str id: WAS application ID (java formated, ex: '/Cell:PreProdNetwork/Node:PreProdNodetest/Server:M998CQU_test_MBR1/')
    :param str kwargs: with ** kwargs get in one directory all additional arguments not filtered by not positional args else, simple dictionnary
    :return: Java Object Work Manager
    :rtype: srt
    """
    adminid = AdminConfig.getid(id)
    id = '%sSchedulerProvider:SchedulerProvider/' % id
    schid = AdminConfig.getid(id)
    schlist = AdminConfig.list('SchedulerConfiguration', schid)
    msg = 'Scheduler %s %s' % (kwargs['name'], '%s')
    
    if schlist.find(kwargs['name']) >= 0:
        msg = msg % 'already exists'
        sch = [ el for el in schlist.splitlines() if el.startswith(kwargs['name']) ][0]
        print(msg)
        return sch
    else:
        msg = msg % 'created'
        opts = [ '[%s "%s"]' % (key,val) for key,val in kwargs.items() ]
        sch = AdminConfig.create('SchedulerConfiguration', schid, opts)
        print(msg)
        return sch


def get_or_create_workManager(id, kwargs):
    """ Get or Create Work Manager::
    
        Resources > Asynchronous beans > Work managers
        
    :param str id: WAS application ID (java formated, ex: '/Cell:PreProdNetwork/Node:PreProdNodetest/Server:M998CQU_test_MBR1/')
    :param str kwargs: with ** kwargs get in one directory all additional arguments not filtered by not positional args
    :return: Java Object Work Manager
    :rtype: srt
    """
    default_opts = [ '[serviceNames "UserWorkArea security AppProfileService com.ibm.ws.i18n"]', '[isGrowable "true"]' ]
    admid = AdminConfig.getid(id)
    msg = 'Work Manager %s %s on %s' % (kwargs['name'], '%s', id)
    wm_list = AdminConfig.list('WorkManagerInfo', admid)

    if wm_list.find(kwargs['name']) >= 0:
        msg = msg % 'already exists'
        wm = [ el for el in wm_list.splitlines() if el.startswith(kwargs['name']) ][0]
        print(msg)
        return wm
    else:
        msg = msg % 'created'
        opts = [ '[%s "%s"]' % (key,val) for key,val in kwargs.items() ] + default_opts
        admid =  AdminConfig.getid(id + 'WorkManagerProvider:WorkManagerProvider/')
        wm = AdminConfig.create('WorkManagerInfo', admid, opts)
        print(msg)
        return wm


def get_or_create_timeManager(id, name, jndiName, numAlarmThreads, **kwargs):
    """ Get or Create Time Manager::
    
        Resources > Asynchronous beans > Timer managers
        
    :param str id: WAS application ID (java formated, ex: '/Cell:PreProdNetwork/Node:PreProdNodetest/Server:M998CQU_test_MBR1/')
    :param str name: Name for the new Time Manager
    :param str jndiName: jndiName for the new Time Manager
    :param str numAlarmThreads: option
    :param dict kwargs: with ** kwargs get in one directory all additional arguments not filtered by not positional args
    :return: Java Object Time Manager 
    :rtype: srt
    """
    id = id + 'TimerManagerProvider:TimerManagerProvider/'
    admid = AdminConfig.getid(id)
    tm_list = AdminConfig.list('TimerManagerInfo', admid)
    msg = 'Timer Manager %s %s on %s' % (name, '%s', id)

    if tm_list.find(name) >= 0:
        msg = msg % 'already exits'
        tm = [ el for el in tm_list.splitlines() if el.startswith(name) ][0]
        print(msg)
        return tm
    else:
        msg = msg % 'created'
        opts = '[[name "%s"] [numAlarmThreads "%s"] [jndiName "%s"]]' % (name, numAlarmThreads, jndiName)
        tm = AdminConfig.create('TimerManagerInfo', admid, opts)
        print(msg)
        return tm


def get_or_create_webcntr(id, name, value, **kwargs):
    """ Get or Create Web Container::
    
        Application servers > {WebSphere application servers} > Web container > Custom properties

    :param str id: WAS application ID (java formated, ex: '/Cell:PreProdNetwork/Node:PreProdNodetest/Server:M998CQU_test_MBR1/')
    :param str name: Name for the new Web Container (key)
    :param str value: for the name of the new property
    :return: Java Object Webcontainer
    :rtype: srt
    """
    admid = AdminConfig.getid(id)
    webcntr = AdminConfig.list('WebContainer', admid)
    props = AdminConfig.list('Property', webcntr)
    msg = 'Webcontainer Property %s %s on %s' % (name, '%s', id)
    
    if props.find(name) >= 0:
        msg = msg % 'already exists'
        prop = [ el for el in props.splitlines() if el.startswith(name) ][0]
        print(msg)
        return prop
    else:
        msg = msg % 'created'
        opts = '[[validationExpression ""] [name "%s"] [description ""] [value "%s"] [required "false"]]' % (name,value)
        prop = AdminConfig.create('Property', webcntr, opts)
        print(msg)
        return prop


def get_or_create_nameSpaceBinding(id, name, nameInNameSpace, stringToBind, **kwargs):
    """ Get or Create a new Name Space Bindings::
    
        Environment > Naming > Name space bindings
        
    :param str id: WAS application ID (java formated, ex: '/Cell:PreProdNetwork/Node:PreProdNodetest/Server:M998CQU_test_MBR1/')
    :param str name: Name for the new Name Space Bindings (key)
    :param str nameInNameSpace: option for new Name Space Bindings
    :param str stringToBind: option for new Name Space Bindings
    :return: Java Object Name Space Binding
    :rtype: srt
    """
    admid = AdminConfig.getid(id)
    namespace_list = AdminConfig.list('StringNameSpaceBinding', admid)
    msg = 'Name Space Bindings %s %s on %s' % (name, '%s', id)

    if namespace_list.find(name) >= 0:
        msg = msg % 'already exists'
        namespace = [ el for el in namespace_list.splitlines() if el.startswith(name) ][0]
        print(msg)
        return namespace
    else:
        msg = msg % 'created'
        nsb = '[[name "%s"] [nameInNameSpace "%s"] [stringToBind "%s" ]]' % (name, nameInNameSpace, stringToBind)
        nsb = AdminConfig.create('StringNameSpaceBinding', admid, nsb)
        print(msg)
        return nsb


#def set_driver_props(ps, ds, opts):
#    """ Set Driver Properties for J2EEResourcePropertySet's DataSources
#
#    :param str ps: Java Object J2EEResourcePropertySet
#    :param str ds: Java Object DataSource
#    :param dict opts: Dict key,val options to pass
#    """
#    def format_value(key, val):
#        if str(val).isdigit():
#            val = int(val)
#            jlt = 'java.lang.Integer'
#        else:
#            val = str(val)
#            jlt = 'java.lang.String'
#
#        return [ ['name', key], ['value', val], ['type', jlt] ]
#
#    opts = [ format_value(key, val) for key, val in opts.items() if key in PROPKEYS ]
#
#    for el in opts:
#        AdminConfig.create('J2EEResourceProperty', ps, el)


def set_ds_connectionPool(ds, connectionPool=None, **kwargs):
    """ Set DataSource connection Pool

    :param obj ds: Java Object DataSource
    :param dict connectionPool: Dict with options for ConnectionPool
    """
    msg = 'Set Connection Pool options: %s' % str(connectionPool)
    attr = AdminConfig.showAttribute(ds, 'connectionPool')
    opts = ymldict2java_opt_list(connectionPool)
    AdminConfig.modify(attr, opts)
    print(msg)


def set_ds_statementCacheSize(ds, statementCacheSize=100, **kwargs):
    """ Set Statement cache size

        Data sources > DATASOURCE_NAME > WebSphere Application Server data source properties

    :param obj ds: Java Object DataSource
    :param dict statementCacheSize: Dict with options for ConnectionPool
    """
    if statementCacheSize:
        msg = 'Set Statement cache size option to %s' % statementCacheSize
        AdminConfig.modify(ds, '[[statementCacheSize "%s"]]' % statementCacheSize)
        print(msg)


def update_ds_properties(ds, **kwargs):
    """ Reset Properties Set and add new values

    :param obj ds: Java Object DataSource
    """
    propkeys = [
        'driverType',
        'portNumber',
        'currentSchema',
        'clientRerouteAlternateServerName',
        'clientRerouteAlternatePortNumber',
        'serverName',
        'databaseName',
        'dataTruncation',
        'dateFormat',
        'timeFormat',
        'libraries',
        'naming',
        'webSphereDefaultIsolationLevel',
        'enableRowsetSupport',
        'extendedDynamic',
        'package',
        'packageLibrary',
        'enableSeamlessFailover',
        'packageCriteria',
        'deferPrepares',
        'blockingReadConnectionTimeout',
        'queryDataSize',
        'fetchSize'
    ]

    # Prepare values
    def format_value(key, val):
        if str(val).isdigit():
            val = int(val)
            jlt = 'java.lang.Integer'
        else:
            val = str(val)
            jlt = 'java.lang.String'

        return [ ['name', key], ['value', val], ['type', jlt] ]

    opts = [ format_value(key, val) for key, val in kwargs.items() if key in propkeys ]

    # Remove All attributes before coping over new attributes
    print('\tReset Values.')
    resetAttrs = []
    resetAttrs.append(['propertySet', []])
    AdminConfig.modify(ds, resetAttrs)

    # Add new values
    print('\tPush new values.')
    ps = ['propertySet', [['resourceProperties', opts]]]
    attrs = []
    attrs.append(ps)
    AdminConfig.modify(ds, attrs)

    set_ds_statementCacheSize(ds, **kwargs)

    if 'connectionPool' in kwargs.keys():
        set_ds_connectionPool(ds, **kwargs)


def get_or_create_datasources(cell, provider, app, cluster_id, server_id, typeds, name, jndiName, **kwargs):
    """ Get or Create Datasource (wrapper)::

        Resources > JDBC > Data sources

    :param str cell: Cellule name (ex: '/Cell:PreProdNetwork/')
    :param str provider: Java obj Provider returned by get_or_create_jdbc_prov()
    :param str app: String to generate Alias (String/user)
    :param str typeds: typeds of Datasource provider
    :param str name: Name for the new DataSources
    :param str jndiName: jndiName for the new resource entry
    """
    if cluster_id: was_id = cluster_id
    else: was_id = server_id

    dSs = AdminConfig.list('DataSource', AdminConfig.getid(was_id)).splitlines()
    dSs = [ el for el in dSs if AdminConfig.showAttribute(el, 'jndiName') == jndiName and AdminConfig.showAttribute(el, 'name') == name ]
    msg = 'DataSource %s %s for %s' % (jndiName, '%s', app)
    
    if typeds == 'mssql':
        dsHelper = 'com.ibm.websphere.rsadapter.MicrosoftSQLServerDataStoreHelper'
    elif typeds == 'toolbox':
        dsHelper = 'com.ibm.websphere.rsadapter.DB2AS400DataStoreHelper'
    elif typeds == 'universal':
        dsHelper = 'com.ibm.websphere.rsadapter.DB2UniversalDataStoreHelper'

    try:
        opts = [
            ['name', name],
            ['datasourceHelperClassname', dsHelper],
            ['description', 'Datasource for %s' % app],
            ['statementCacheSize', 100],
            ['jndiName', jndiName]
        ]
        ds = AdminConfig.create('DataSource', provider, opts)
        ps = AdminConfig.create('J2EEResourcePropertySet', ds, [])
        #set_driver_props(ps, ds, kwargs)
        msg = msg % 'created'
        print(msg)
        return ds
    except ScriptingException, err:
        if str(err).find('because the jndiName attribute of an existing') >= 0:
            print(msg % 'already exists')
            return dSs[0]
        else:
            raise err


def set_or_unset_httponlycookie(server_id, httponlycookie, **kwargs):
    """ Set or Unset Httponly Cookie::
    
        Application servers > {WebSphere application servers} > Web container > Session management > Cookies > Set session cookies to HTTPOnly to help prevent cross-site scripting attacks
    
    :param str server_id: WAS Server Name /Cell:CELLNAME/Node:NODENAME/ServerName:SERVERNAME/
    :param str httponlycookie: Value (True or False)
    :param str kwargs: with ** kwargs get in one directory all additional arguments not filtered by not positional args
    """

    if httponlycookie == 'true': msg = 'set'
    else: msg = 'unset'
    msg = 'session cookies to HTTPOnly %s for %s' % (msg, server_id)

    cookie = AdminConfig.list('Cookie', AdminConfig.getid(server_id))

#     sessionid, cookie = cookie.split('(')
#     cookie = '(%s)' % cookie[:-1]
#     opts = '[[name "%s"] [httpOnly "%s"]]' % (sessionid, httponlycookie)

    opts = '[[ httpOnly %s ]]' % httponlycookie
    AdminConfig.modify(cookie, opts)

    print(msg)


def get_or_create_toolbox_datasources(cell, wsnode, wsserver, provider, scope, type, appl, dshost, env, *args):
    """ Get or Create Toolbox Datasource (use old script developed by YAC)::
    
        Resources > JDBC > Data sources
        
    :param str cell: Cellule name (ex: '/Cell:PreProdNetwork/')
    :param str wsnode: WAS Node Name (base_node_name in Ansible yaml configuration)
    :param str wsserver: WAS Server Name (base_cell_name in Ansible yaml configuration)
    :param str provider: Java obj Provider returned by get_or_create_jdbc_prov()
    :param str scope: For which app Datasource will be create Server ? Cluster ? (Javastring object)
    :param str type: toolbox/universal/mssql
    :param str appl: Targeted Application for which Datasource will be created
    :param str dshost: host for the DB to connect config in apps.py
    :param str env: application environment (BETA,TEST,CPK,400,200,500)
    :param list args: with * args get in one list all additional arguments not filtered by not positional args
    :return: Java Object Toolbox Datasource
    :rtype: srt
    """
    return checkdatasource.checkdatasource(AdminConfig, wsnode, wsserver, appl, dshost, '', env, type, provider, cell)


def get_or_create_universal_datasources(cell, wsnode, wsserver, provider, scope, type, appl, dshost, dsmapdb, env, *args):
    """ Get or Create Universal Datasource (use old script developed by YAC)::
    
        Resources > JDBC > Data sources
        
    :param str cell: Cellule name (ex: '/Cell:PreProdNetwork/')
    :param str wsnode: WAS Node Name (base_node_name in Ansible yaml configuration)
    :param str wsserver: WAS Server Name (base_cell_name in Ansible yaml configuration)
    :param str provider: Java obj Provider returned by get_or_create_jdbc_prov()
    :param str scope: For which app Datasource will be create Server ? Cluster ? (Javastring object)
    :param str type: toolbox/universal/mssql
    :param str appl: Targeted Application for which Datasource will be created
    :param str dshost: host for the DB to connect config in apps.py
    :param str dsmapdb: db name
    :param str env: application environment (BETA,TEST,CPK,400,200,500)
    :param list args: with * args get in one list all additional arguments not filtered by not positional args
    :return: Java Object Universal Datasource
    :rtype: srt
    """
    return checkdatasource.checkdatasource(AdminConfig, wsnode, wsserver, appl, dshost, dsmapdb, env, type, provider, cell)


def get_or_create_mssql_datasources(provider, scope, cell, dbname, dbport, dburl):
    """ Get or Create MSSQL Datasource::
    
        Resources > JDBC > Data sources
        
    :param str provider: Java obj Provider returned by get_or_create_jdbc_prov()
    :param str scope: For which app Datasource will be create Server ? Cluster ? (Javastring object)
    :param str cell: Cellule name (ex: '/Cell:PreProdNetwork/')
    :param str dbname: Name of the new Database
    :param str dbport: Port of the Database to connect
    :param str dburl: URL of the Database
    :return: Java Object MS SQL Datasource
    :rtype: srt
    """
    msg = 'DataSource %s %s for %s' % (dbname, '%s', scope)
    datasources = get_all_datasources(cell)

    if datasources.find(dbname) < 0:
        datasource = (
            '-name ' + dbname,
            '-jndiName ' + dbname,
            '-dataStoreHelperClassName com.ibm.websphere.rsadapter.MicrosoftSQLServerDataStoreHelper',
            '-containerManagedPersistence true',
            '-description "MS SQL datasources for %s"' % scope,
            '-configureResourceProperties [[databaseName java.lang.String %s] [portNumber java.lang.Integer %s] [serverName java.lang.String %s]]' % (dbname, dbport, dburl)
        )
        datasource = '[%s]' % ' '.join(datasource)
        datasource = AdminTask.createDatasource(provider, datasource)

        msg = msg % 'created'
        print(msg)
        return datasource
    else:
        datasource = [ el for el in datasources.splitlines() if el.startswith(dbname) ][0]
        
        msg = msg % 'already exists'
        print(msg)
        return datasource


def get_all_datasources(cell):
    """ List all Datasources::
    
        Resources > JDBC > Data sources
        
    :param str cell: Cellule name (ex: '/Cell:PreProdNetwork/')
    :return: List of Datasource already created
    :rtype: srt
    """
    return AdminConfig.list('DataSource', AdminConfig.getid(cell))


def get_or_create_jdbc_prov(typeds, scope, id, **kwargs):
    """ Get or Create JDBC Provider::
    
        Resources > JDBC > JDBC providers
        
    :param str typeds: typeds of Datasource provider
    :param str scope: on which scope create the provider
    :return: Java Object JDBC Provider
    :rtypeds: srt
    """
    opts = {
        'scope': scope,
        'implementationType': 'Connection pool data source',
    }

    if typeds == 'mssql':
        opts['name'] = 'Microsoft SQL Server JDBC Driver'
        opts['databaseType'] = 'SQL Server'
        opts['providerType'] = 'Microsoft SQL Server JDBC Driver'
        opts['classpath'] = '[${MICROSOFT_JDBC_DRIVER_PATH}/sqljdbc40.jar]'
    elif typeds == 'toolbox':
        opts['name'] = 'DB2 UDB for iSeries (Toolbox)'
        opts['databaseType'] = 'DB2'
        opts['providerType'] = 'DB2 UDB for iSeries (Toolbox)'
        opts['classpath'] = '[${OS400_TOOLBOX_JDBC_DRIVER_PATH}/jt400.jar]'
    elif typeds == 'universal':
        opts['name'] = 'DB2 Universal JDBC Driver Provider'
        opts['databaseType'] = 'DB2'
        opts['providerType'] = 'DB2 Universal JDBC Driver Provider'
        opts['classpath'] = '[${DB2UNIVERSAL_JDBC_DRIVER_PATH}/db2jcc.jar]'
    else:
        opts = None

    msg= 'JDBCProvider "%s" %s for %s' % (opts['name'], '%s', id)
    providers = AdminConfig.list('JDBCProvider', AdminConfig.getid(id))

    if providers.find(opts['name']) < 0:
        msg = msg % 'created'

        opts = [ '-%s "%s"' % (key,val) for key,val in opts.items() ]
        tmp = AdminTask.createJDBCProvider(opts)

        print(msg)
        return tmp
    else:
        msg = msg % 'already exists'
        tmp = [ el for el in providers.splitlines() if el.find(opts['name']) >= 0 ][0]

        print(msg)
        return tmp


def get_or_create_jmsCF(was_id, user=None, authDataAlias=None, authDataPassword=None, connectionPool=None, sessionPool=None, **kwargs):
    """ Get or create JMS Connection Factory::

        Resources > JMS > Connection factories

    :param str was_id: String id (ex: /Cell:RefNetwork/ServerCluster:BL2_apps5/)
    :param str username,password: Use that variable at None to filter kwargs and use it to pass kwargs in simple way
    :param dict kwargs: with ** kwargs get in one directory all additional arguments not filtered by not positional args
    :return: Java Object JMS Connection Factory
    :rtype: srt
    """
    id = AdminConfig.getid(was_id)
    msg = '%s %s on %s' % (kwargs['jndiName'], '%s', was_id)        # format message to display

    opts = ymldict2java_list_string(kwargs)

    try:
        jmscf = AdminTask.createWMQConnectionFactory(id, opts)
        print(msg % 'created')
        return jmscf
    except ScriptingException, err:
        if str(err).find('already exists') >= 0:
            print(msg % 'already exists')
            jmscf = AdminTask.listWMQConnectionFactories(id).splitlines()
            jmscf = [ el for el in jmscf if el.startswith(kwargs['name']) ][0]
            return jmscf
        else:
            raise err


def set_props_jmscf(jmscf, connectionPool=None, sessionPool=None, **kwargs):
    """ Set Custom properties to JMS Connection Factory::

        Resources > JMS > Connection factories

    :param str jmscf: Java Object JMS Connection Factory
    """
    msg = 'Set custom properties to JMSCF'
    del kwargs["authDataPassword"]
    del kwargs['authDataAlias']
    del kwargs['user']
    opts = ymldict2java_list_string(kwargs)
    AdminTask.modifyWMQConnectionFactory(jmscf,opts)
    print(msg)



def get_or_create_jmsQueue(was_id, advancedProperties=None, **kwargs):
    """ Get or create JMS Queue::

        Resources > JMS > Queues

    :param str was_id: WAS application ID (java formated, ex: '/Cell:PreProdNetwork/Node:PreProdNodetest/Server:M998CQU_test_MBR1/')
    :param dict advancedProperties: Dictionary with Advanced Properties for jms queue
    :param dict kwargs: with ** kwargs get in one directory all additional arguments not filtered by not positional args
    :return: Java Object JMS Queue
    :rtype: srt
    """
    jndiName, name = kwargs['jndiName'], kwargs['name']
    msg = 'JMS Queue %s %s on %s' % (kwargs['jndiName'], '%s', was_id)
    was_id = AdminConfig.getid(was_id)
    opts = [ '-%s %s' % (key,val) for key,val in kwargs.items() ]

    wmqqueues = AdminTask.listWMQQueues(was_id).splitlines()
    #wmqqueues = [ el for el in wmqqueues if el.startswith(kwargs['name'])]
    wmqqueues = [ el for el in wmqqueues
        if AdminConfig.showAttribute(el, 'jndiName') == jndiName and AdminConfig.showAttribute(el, 'name') == name
    ]

    if len(wmqqueues) > 0:
        wmqqueues = wmqqueues[0]
        print(msg % 'already exists')
    else:
        wmqqueues = AdminTask.createWMQQueue(was_id, opts)
        print(msg % 'created')

    if advancedProperties:
        opts = [ '-%s %s' % (key,val) for key,val in advancedProperties.items() ]
        AdminTask.modifyWMQQueue(wmqqueues, opts)
        print('Put Advanced Properties to JMS Queue %s' % kwargs['jndiName'])


def set_auth(obj, jaas):
    """ Set Authentication on object

    :param obj obj: Object (ex: DataSources, JMS MQ, JMS CF, ...)
    :param str jaas: Alias User (EXAMPLE/User) returned by create_jaas
    """
    if not obj or not jaas: return None

    if obj.find('#MQConnectionFactory_') >= 0:
        msg = 'Add %s to %s' % (jaas, obj)
        opts = { 'mappingAlias': 'DefaultPrincipalMapping',
            'containerAuthAlias': jaas,
            'xaRecoveryAuthAlias': jaas
        }
        opts = [ '-%s %s' % (key,val) for key,val in opts.items() ]

        AdminTask.modifyWMQConnectionFactory(obj, opts)

        print(msg)
    else:
        print "Configuring JAAS for DataSource %s" % jaas
        opts = [['mapping', [['authDataAlias', jaas], ['mappingConfigAlias', "DefaultPrincipalMapping"]]], ['authDataAlias', jaas]]
        AdminConfig.modify(obj, opts)


def create_jaas(authDataAlias=None, user=None, authDataPassword=None, **kwargs):
    """ Create new JAAS - J2C authentication data

    :param authDataAlias: Auth Alias given in DataSource YML file
    :param user: User Name
    :param authDataPassword: New password for User
    :return: Java Object JAAS - J2C authentication data (auth Alias)
    :rtype: str
    """
    if not authDataAlias or not authDataPassword: return None

    secobj = AdminConfig.getid('/Security:/')
    msg = 'Authentication alias %s %s' % (authDataAlias, '%s')
    authlist = AdminConfig.list('JAASAuthData').splitlines()
    aliaslist = [ AdminConfig.showAttribute(el, 'alias') for el in authlist ]
    
    if authDataAlias in aliaslist:
        jaas = [ el for el in authlist if AdminConfig.showAttribute(el,'alias') == authDataAlias ][0]
        print(msg % ('already exists'))
        return authDataAlias

    opts = [['alias', authDataAlias], ['userId', user], ['password', authDataPassword]]
    jaas = AdminConfig.create('JAASAuthData', secobj, opts)
    msg = msg % ('created')
    print(msg)
    return authDataAlias


def set_jvm_prop(jvm, name, value, **kwargs):
    """ create or modify System property

    :param obj jvm: Java Virtual Machine
    :param str name, value: Key, Value for the Property
    """
    props = AdminConfig.list('Property', jvm).splitlines()
    propsID = props
    props = [ el.split('(')[0] for el in props ]

    if value == 'True': value = 'true'
    if value == 'False': value = 'false'

    if name not in props:
        msg = 'created'
        AdminConfig.create('Property', jvm, '[[name "%s"] [value "%s"]]' % (name, value))
    else:
        msg = 'already exists, modifying'
        for id in propsID:
            if id.startswith(name):
                AdminConfig.modify(id, [['value', value]])

    msg = 'systemProperties %s %s' % (name, msg)
    print(msg)



def create_mqjms(jmsprov, qmgrName=None, qmgrHostname=None, authDataAlias=None, description=None,
        authDataPassword=None, name=None, jndiName=None, qmgrPortNumber=None,
        qmgrSvrconnChannel=None, user=None, connectionNameList=None, **kwargs):
    """ Create Queue connection factories::

        Resources > JMS > Queue connection factories

    :param obj jmsprov: WebSphere MQ JMS Provider
    :param str qmgrName: Queue Manager (name)
    :param str qmgrHostname: url host mq
    :param str user: User
    :param str pwd: Password
    :param str name: Queue connection factories Name
    :param str jndiName: Queue connection factories jndi/name
    :param str qmgrPortNumber: Port connection
    :param str qmgrSvrconnChannel: String Server Channel (SVRCHAN/CON)
    """

    tmp = {
        'type': 'QCF',
        'wmqTransportType': 'BINDINGS_THEN_CLIENT',
        'sslType': 'NONE',
        'clientId': '',
        'providerVersion': '',
        'mappingAlias': 'DefaultPrincipalMapping',
        'componentAuthAlias': '',
        'xaRecoveryAuthAlias': '',
        'support2PCProtocol': 'true',
        'description': ''
    }

    if name: tmp['name'] = name
    if jndiName: tmp['jndiName'] = jndiName
    if qmgrName: tmp['qmgrName'] = qmgrName
    if qmgrSvrconnChannel: tmp['qmgrSvrconnChannel'] = qmgrSvrconnChannel
    if qmgrHostname: tmp['qmgrHostname'] = qmgrHostname
    if qmgrPortNumber: tmp['qmgrPortNumber'] = qmgrPortNumber
    if description: tmp['description'] = '"%s"' % description
    if connectionNameList: tmp['connectionNameList'] = connectionNameList

    if authDataAlias and authDataPassword and user:
        host, _ = authDataAlias.split('/')
        authalias = jaas.configjaas(AdminConfig, host, user, authDataPassword)
        tmp['containerAuthAlias'] = authalias

    tmp = '[%s]' % (' '.join([ '-%s %s' % (el) for el in tmp.items() ]))

    msg = 'MQ Connection Factory %s %s on %s' % (jndiName, '%s', jmsprov)
    try:
        AdminTask.createWMQConnectionFactory(AdminConfig.getid(jmsprov), tmp)
        print(msg % 'created')
    except ScriptingException, err:
        if str(err).find('already exists') >= 0:
            print(msg % 'already exists')
        else:
            raise err


def get_aliases(id):
    """ Get aliases defined on Cellule

    :param str id: id of the VirtualHost on the Cellule
    :return: Alias created in Vhost
    :rtype: srt
    """
    vhosts = AdminConfig.list('HostAlias', AdminConfig.getid(id)).splitlines()

    if len(vhosts) > 0:
        vhosts = [
            ':'.join([ el[1:-1].split()[-1] for el in AdminConfig.show(el).splitlines() ])
        for el in vhosts ]

    return vhosts


def create_alias(id, hostname, port, **kwargs):
    """ Create alias in vhost (id)

    :param str id: VirutalHost id
    :param host: Host of the new alias
    :param port: Port of the new alias
    """
    vhosts = get_aliases(id)
    alias = '%s:%s'% (hostname, port)

    if alias not in vhosts:
        host_port = '[[hostname "%s"] [port "%s"]]' % (hostname, port)
        AdminConfig.create('HostAlias', AdminConfig.getid(id), host_port)
        msg = 'created'
    else:
        msg = 'already exists'

    msg = 'Alias %s %s for %s' % (alias, msg, id)
    print(msg)


def get_or_create_vhost(cell, vhost):
    """ create vhost if not exists::
    
        Environment > Virtual hosts

    :param str cell: Cellule name (ex: '/Cell:PreProdNetwork/')
    :param str vhost: Virtual Host (ex: 'JADER_test_vhost')
    """
    tmp = AdminConfig.list('VirtualHost', AdminConfig.getid(cell))

    if tmp.find(vhost) < 0:
        tmp = AdminConfig.create('VirtualHost', AdminConfig.getid(cell), '[[name "'+ vhost +'"]]')
        msg = 'created'
    else:
        tmp = [ el for el in tmp.splitlines() if el.find(vhost) >= 0 ][0]
        msg = 'already exists'

    msg = 'VirtualHost %s %s on %s.' % (vhost, msg, cell)
    print(msg)
    return tmp


def create_env_provider(id):
    """ Create env provider::
    
        Resources > Resource Environment > Resource Environment Providers

    :param str id: WAS application ID (java formated, ex: '/Cell:PreProdNetwork/Node:PreProdNodetest/Server:M998CQU_test_MBR1/')
    """
    AdminConfig.create('ResourceEnvironmentProvider', AdminConfig.getid(id), '[[name "ResourcesProviderForJNDI"]]')


# def get_all_env_providers(id):
#     """ get list of all env providers to check if already exists::
#     
#         Resources > Resource Environment > Resource Environment Providers
# 
#     :param str id: WAS application ID (java formated, ex: '/Cell:PreProdNetwork/Node:PreProdNodetest/Server:M998CQU_test_MBR1/')
#     :return: All Environment Provider for WAS. Return bool 1 if exist 0 if false
#     :rtype: bool
#     """
#     tmp = AdminConfig.list('ResourceEnvironmentProvider', AdminConfig.getid(id))
#     tmp = len(tmp)
#     return tmp == 0


def common_creation_was(wasdict):
    """ Execute common operations to was::
    
        Servers > Server Types > WebSphere application servers

    :param dict wasdict: Contain information for WAS creations
    
    **wasdict** must contain:
    
    :param str base_node_name: WAS Node Name (base_node_name in Ansible yaml configuration)
    :param str ws_application_server: WAS Server Name (base_cell_name in Ansible yaml configuration)
    :param str was_user: User name with which the WAS will start
    :param str was_group: Group name with which the WAS will start
    :param str uppercase_name: The UpperCase name of the was app (item.was.5 in yaml configuration files)
    """
    serverprocs.configureusergroup(AdminConfig,
        wasdict['base_node_name'],
        wasdict['ws_application_server'],
        wasdict['was_user'],
        wasdict['was_group']
    )

    serverprocs.modifycookiename(AdminConfig,
        wasdict['base_node_name'],
        wasdict['ws_application_server'],
        wasdict['uppercase_name']
    )


def create_cluster_member(cluster_name, wasdict):
    """ create cluster member for mbr2::
    
        Servers > Clusters > WebSphere application server clusters

    :param str cluster_name: Cluster Name
    :param dict wasdict: Contain information for WAS creations
    
    **wasdict** must contain:
    
    :param str base_node_name: Node name
    :param str str ws_application_server: WAS Server Name (base_cell_name in Ansible yaml configuration)
    :param str was_server_alias: base web url (CNAME to web server) (ex: node-pp-test.jablux.gfdi.be)
    :param str default_port: 21 for MBR1/STANDALONE, 22 for MBR2 concatenated with num application (item.was.1)
    :param str lowercase_name: The LowerCase name of the was app (item.was.2)
    """
    createserver.createclustermember(
        AdminConfig,
        AdminTask,
        wasdict['base_node_name'],
        cluster_name,
        wasdict['ws_application_server'],
        wasdict['was_server_alias'],
        wasdict['default_port'],
        wasdict['lowercase_name']
    )


def create_server(wasdict):
    """ create server was, for standalone and mbr1::
    
        Servers > Server Types > WebSphere application servers
        
    :param dict wasdict: Contain information for WAS creations
    
    **wasdict** must contain:

    :param str base_node_name: Node name
    :param str str ws_application_server: WAS Server Name (base_cell_name in Ansible yaml configuration)
    :param str was_server_alias: base web url (CNAME to web server) (ex: node-pp-test.jablux.gfdi.be)
    :param str default_port: 21 for MBR1/STANDALONE, 22 for MBR2 concatenated with num application (item.was.1)
    :param str lowercase_name: The LowerCase name of the was app (item.was.2)
    """
    createserver.createserver(
        AdminConfig,
        AdminTask,
        wasdict['base_node_name'],
        wasdict['ws_application_server'],
        wasdict['was_server_alias'],
        wasdict['default_port'],
        wasdict['lowercase_name']
    )


def convert_cluster(cluster_name, wasdict):
    """ convert standalone was in a cluster::
    
        Servers > Clusters > WebSphere application server clusters

    :param str cluster_name: Cluster Name
    :param dict wasdict: Contain information for WAS creations
    
    **wasdict** must contain:
    
    :param str ws_application_server: WAS Server Name (base_cell_name in Ansible yaml configuration)
    :param str base_node_name: Node name
    """
    createserver.convertcluster(
        AdminConfig,
        wasdict['base_node_name'],
        cluster_name,
        wasdict['ws_application_server'],
    )


def create_standalone_was(wasdict):
    """ create standalone was server

    :param dict wasdict: Contain information for WAS creations
    """
    create_server(wasdict)
    common_creation_was(wasdict)


def create_mbr1_was(cluster_name, wasdict):
    """ create mbr1 was server

    :param dict wasdict: Contain information for WAS creations
    """
    create_server(wasdict)
    common_creation_was(wasdict)
    convert_cluster(cluster_name, wasdict)


def create_mbr2_was(cluster_name, wasdict):
    """ create mbr2 was server

    :param dict wasdict: Contain information for WAS creations
    """
    create_cluster_member(cluster_name, wasdict)
    common_creation_was(wasdict)


def create_new_was_dispatcher(wasdict):
    """ function dispatcher to standalone, mbr1, mbr2
    
    :param dict wasdict: Contain ALL information for ALL function of the WAS creation
    """
    if not wasdict['clustered']:
        create_standalone_was(wasdict)
    else:
        #cluster_name = '_'.join(wasdict['ws_application_server'].split('_')[:-1])
        cluster_name = wasdict['was_cluster_name']
        if wasdict['ws_application_server'].endswith('MBR1'):
            create_mbr1_was(cluster_name, wasdict)
        elif wasdict['ws_application_server'].endswith('MBR2'):
            create_mbr2_was(cluster_name, wasdict)


def create_was(wasdic):
    """ Basic function to create WAS (main function to recolt errors)

    :param dict wasdict: Contain information for WAS creations
    """
    msg = '%s %s on %s' % (wasdic['ws_application_server'], '%s', wasdic['base_node_name'])
    try:
        create_new_was_dispatcher(wasdic)
    except ScriptingException, err:
        if str(err).find('exists within node') >= 0 or str(err).find('already exists on node') >= 0:
            print(msg % 'already exists')
        else:
            raise err

